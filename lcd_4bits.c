/* Main.c file generated by New Project wizard
 *
 * Created:   Tue Sep 7 2021
 * Processor: STM32F103C6
 * Compiler:  Keil for ARM
 */

#include <stm32f1xx.h>
#include <lcd_4bits.h>

/*
//Cabecera de string_len, que igualmente no se utiliza
uint8_t string_len(char* data);

uint8_t string_len(char* data){
    
   uint8_t ret=0;
    for(;*data!='\0'||data;data++)
        ret++;
    return ret;
 }
 */
 

/*Outputs string to LCD.
Receives the String + the size of the String in Characters*/
void lcd_string(char* data, uint8_t nBytes)	
{
uint8_t i;
   
	if (!data) return;			//check to make sure we have a good pointer
	 
	for(i=0; i<nBytes; i++){		//Print data in LCD
		lcd_sendData(data[i]);
	}
}

//Inicializacion del LCD en modo 4 bits
void lcd_init(){  
   
  LCD_PORT = 0x44333333;    		/* PA0-PA7 as outputs */
  LCD_PIN_OUT &= ~(1<<LCD_EN);  	//LCD_EN=0

  delay_us(3000);              			//Delay de 3ms
  lcd_sendCommand(0x33);          		//Send $33 for init
  lcd_sendCommand(0x32);          		//Send $32 for init
  lcd_sendCommand(0x28);          		//Init LCD 2 line, 5x7 Matrix
  lcd_sendCommand(0x0e);          		//Display On, Curson On
  lcd_sendCommand(0x01);          		//Clear LCD

  delay_us(2000);              			//Delay de 2ms
  lcd_sendCommand(0x06);          		//Shift Cursor Right
}

//Codigo para enviar un comando al LCD
void lcd_sendCommand (uint8_t cmd)
{
   LCD_PORT_BRR = (1<<LCD_RS); /* RS = 0 for command */	
   lcd_putValue(cmd);
}

//Codigo para enviar un Char al LCD
void lcd_sendData (uint8_t data)
{
   LCD_PORT_BSRR = (1<<LCD_RS); /* RS = 1 for data */
   lcd_putValue(data);
}

/* Codigo para enviar valores al LCD.
Funciona en 4 bits. Primero envia la parte superior,
y luego envia la parte inferior del dato.
*/
void lcd_putValue(unsigned char value)
{
   LCD_PORT_BRR = 0x0F;                 			/* clear PA0-PA3 */
   LCD_PORT_BSRR = (value>>4)&0x0F;     		/* put high nibble on PA0-PA3 */
   LCD_PIN_OUT |= (1<<LCD_EN);        	 		/* EN = 1 for H-to-L pulse */
   delay_us(1);                       					/* make EN pulse wider. You can use delay_us(2); too */
   LCD_PIN_OUT &= ~ (1<<LCD_EN);       		/* EN = 0 for H-to-L pulse */
   delay_us(100);                       				/* wait */

   LCD_PORT_BRR = 0x0F;                 			/* clear PA0-PA3 */
   LCD_PORT_BSRR = value&0x0F;          	 	/* put low nibble on PA0-PA3 */
   LCD_PIN_OUT |= (1<<LCD_EN);         			/* EN = 1 for H-to-L pulse */
   delay_us(1);                       					/* make EN pulse wider */
   LCD_PIN_OUT &= ~(1<<LCD_EN);         		/* EN = 0 for H-to-L pulse */
   delay_us(100);                       				/* wait */
}
