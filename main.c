/* Main.c file generated by New Project wizard
 *
 * Created:   Tue Sep 7 2021
 * Processor: STM32F103C6
 * Compiler:  Keil for ARM
 */

#include <stm32f10x.h>
#include <string.h>

#define LCD_RS 4
#define LCD_RW 6
#define LCD_EN 5

/*CABECERAS*/
void delay_us (uint16_t t);
void lcd_init(void);
void lcd_sendData (uint8_t data);
void lcd_sendCommand (uint8_t cmd);
void lcd_putValue (uint8_t value);
void lcd_string(char* data);


uint8_t string_len(char* data);



int main (void)
 { 
   // Write your code here
   
    RCC->APB2ENR |= 0xFC;        /* Enable clocks for GPIO ports */
    KEYPAD_Init();
    
    //GPIOA->CRL = 0x44333333;    // PA0-PA7 as outputs => Esto no va, los pines los usa el LCD
	//Los de keypad los usas en KEYPAD_init
    
    //4 indica Entrada de Alta Impedancia.
    //3 Indica Salida
    //8 Indica Entrada

    
    
   while (1){ 
	 
	KEYPAD_Scan(&a);
	 delay_us(3000);
      }
 }    

void delay_us (uint16_t t)
{
  volatile unsigned long l = 0;
  uint16_t i;
  for( i= 0; i < t; i++)
  for(l = 0; l < 6; l++){
  }
}

//devuelve el tamaño de la String

uint8_t string_len(char* data){
    
   uint8_t ret=0;
    for(;*data!='\0'||data;data++)
        ret++;
    return ret;
 }

//Recibe una String, calcula su tamaño y lo imprime en pantalla.
void lcd_string(char* data)	//Outputs string to LCD
{
uint8_t i,nBytes;

	//check to make sure we have a good pointer
	if (!data) return;
	  
	//Numero de Bytes a imprimir
	nBytes = string_len(data);

	// print data
	for(i=0; i<nBytes; i++)
	{
		lcd_sendData(data[i]);
	}
}

//MODO 4 BITS
void lcd_init(){  

  GPIOA->ODR &= ~(1<<LCD_EN);  //LCD_EN=0

  delay_us(3000);              		//Delay de 3ms
  lcd_sendCommand(0x33);          //Send $33 for init
  lcd_sendCommand(0x32);          //Send $32 for init
  lcd_sendCommand(0x28);          //Init LCD 2 line, 5x7 Matrix
  lcd_sendCommand(0x0e);          //Display On, Curson On
  lcd_sendCommand(0x01);          //Clear LCD

  delay_us(2000);              		//Delay de 2ms
  lcd_sendCommand(0x06);          //Shift Cursor Right
}

void lcd_sendCommand (uint8_t cmd)
{
   GPIOA->BRR = (1<<LCD_RS); /* RS = 0 for command */	
   lcd_putValue(cmd);
}

void lcd_sendData (uint8_t data)
{
   GPIOA->BSRR = (1<<LCD_RS); /* RS = 1 for data */
   lcd_putValue(data);
}

void lcd_putValue(unsigned char value)
{
  GPIOA->BRR = 0x0F;                 			/* clear PA0-PA3 */
  GPIOA->BSRR = (value>>4)&0x0F;     		/* put high nibble on PA0-PA3 */
  GPIOA->ODR |= (1<<LCD_EN);        	 	/* EN = 1 for H-to-L pulse */
  delay_us(1);                       				/* make EN pulse wider. You can use delay_us(2); too */
  GPIOA->ODR &= ~ (1<<LCD_EN);       		/* EN = 0 for H-to-L pulse */
  delay_us(100);                       			/* wait */

  GPIOA->BRR = 0x0F;                 			/* clear PA0-PA3 */
  GPIOA->BSRR = value&0x0F;          	 	/* put low nibble on PA0-PA3 */
  GPIOA->ODR |= (1<<LCD_EN);         		/* EN = 1 for H-to-L pulse */
  delay_us(1);                       				/* make EN pulse wider */
  GPIOA->ODR &= ~(1<<LCD_EN);         	/* EN = 0 for H-to-L pulse */
  delay_us(100);                       			/* wait */
}
