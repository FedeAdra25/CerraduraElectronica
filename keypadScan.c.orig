/* Main.c file generated by New Project wizard
 *
 * Created:   Tue Sep 7 2021
 * Processor: STM32F103C6
 * Compiler:  Keil for ARM
 */

#include <stm32f1xx.h>
#include <string.h>
<<<<<<< HEAD
#include <keypadScan.h>

/*CABECERAS*/
void delay_us (uint16_t t);

unsigned char a ;

int main (void)
 { 
   // Write your code here
   
    RCC->APB2ENR |= 0xFC;        /* Enable clocks for GPIO ports */
    KEYPAD_Init();
    
    //GPIOA->CRL = 0x44333333;    // PA0-PA7 as outputs => Esto no va, los pines los usa el LCD
	//Los de keypad los usas en KEYPAD_init
    
    //4 indica Entrada de Alta Impedancia.
    //3 Indica Salida
    //8 Indica Entrada

    
    
   while (1){ 
	 
	KEYPAD_Scan(&a);
	 delay_us(3000);
      }
 }   

void delay_us (uint16_t t)
{
  volatile unsigned long l = 0;
  uint16_t i;
  for( i= 0; i < t; i++)
  for(l = 0; l < 6; l++){
  }
}
=======
#include "keypadScan.h"
>>>>>>> branchDeFede
/*
 * KeypadScanLib.c
 *
 * Created: 19-Apr-21 4:50:53 PM
 *  Author: fedea
 */





//Definicion de variable global privada
static const uint8_t teclas[4][4]= {
	{'7','8','9','A'},
	{'4','5','6','B'},
	{'1','2','3','C'},
	{'*','0','#','D'},
};



//Prototipo para funcion privada 
static uint8_t getKeyPressed(uint8_t *key);


/*******************************************************
FUNCION PARA INICIALIZAR EL TECLADO MATRICIAL
********************************************************/
void KEYPAD_Init(){
<<<<<<< HEAD
	 GPIOA->CRH = 0x88883333;    /* PA8-PA11 as Outputs (FILAS) && PA12-PA15 as Inputs (COLUMNAS)*/
=======
	 GPIOA->CRH = 0x33338888;    /* PA8-PA11 as Outputs && PA12-PA15 as Inputs*/
>>>>>>> branchDeFede
   
	//KEYPAD_DDR = 0xF0; //inicializo "filas como salidas", columnas como entradas
	//KEYPAD_PORT = 0x0F; //activo pullup intenro
}

/********************************************************
FUNCION PARA ESCANEAR UN TECLADO MATRICIAL Y DEVOLVER LA
TECLA PRESIONADA UNA SOLA VEZ. TIENE DOBLE VERIFICACION Y
MEMORIZA LA ULTIMA TECLA PRESIONADA
DEVUELVE:
0 -> NO HAY NUEVA TECLA PRESIONADA
1 -> HAY NUEVA TECLA PRESIONADA Y ES *pkey
********************************************************/
uint8_t KEYPAD_Scan (uint8_t *pkey)
{
	static uint8_t Old_key;
	static uint8_t Key, Last_valid_key=0xFF; // no hay tecla presionada
	if(!getKeyPressed(&Key)) { //getKeyPressed hace barrido del teclado
		Old_key=0xFF; // no hay tecla presionada
		Last_valid_key=0xFF;
		return 0;
	}
	if(Key==Old_key) { //2da verificación
		if(Key!=Last_valid_key){ //evita múltiple detección
			*pkey=Key;
			Last_valid_key = Key;
			return 1;
		}
	}
	Old_key=Key; //1era verificación
	return 0;
}

//BARRIDO
static uint8_t getKeyPressed(uint8_t *key)
{
<<<<<<< HEAD
	const uint16_t aux[4]={0x7FFF,0xBFFF,0xDFFF,0xEFFF}; //{F1,F2,F3,F4} -> aux[i] implica 0 en Fila i
=======
	const uint32_t aux[4]={0x00007FFF,0x0000BFFF,0x0000DFFF,0x0000EFFF}; //{F1,F2,F3,F4} -> aux[i] implica 0 en Fila i
>>>>>>> branchDeFede
	uint8_t i;
	
	//KEYPAD_PORT|=0xF0;	//¿Que hago con el PullUp interno? 0b11110000 era de los pines de PD0 a PD3, activo pull up en los pines PA8-PA11??
	GPIOA->CRH = 0x88883333;	//verificar.

	for(i=0;i<4;i++){
		GPIOA->ODR = aux[i]; 				//va poniendo un cero en cada fila => LEE COMENTARIO ARRIBA	0111 1111
		if(~KEYPAD_PIN & KEYPAD_PORT0){		//KEYPAD_PIN es GPIOA->IDR	1er iteracion 0111 1111 1111 1111 & 1000 0000 0000 0000
			//1 en Pin D0
			*key=teclas[i][0];
			return 1;
		}
		if(~KEYPAD_PIN & KEYPAD_PORT1){
			//1 en Pin D1
			*key=teclas[i][1];
			return 1;
		}
		if(~KEYPAD_PIN & KEYPAD_PORT2){
			//1 en Pin D2
			*key=teclas[i][2];
			return 1;
		}
		if(~KEYPAD_PIN & KEYPAD_PORT3){
			//1 en Pin D3
			*key=teclas[i][3];
			return 1;
		}
	}
	return 0;
}
 
